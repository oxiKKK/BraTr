/*
 *       Copyright (c) 2022, oxiKKK
 *
 *   This program is licensed under the MIT license. By downloading, copying,
 *    installing or using this software you agree to this license.
 *
 *       License Agreement
 *
 *   Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
 *    to deal in the Software without restriction, including without limitation
 *    the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *    and/or sell copies of the Software, and to permit persons to whom the
 *    Software is furnished to do so, subject to the following conditions:
 *
 *   The above copyright notice and this permission notice shall be included
 *    in all copies or substantial portions of the Software.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 *    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 *    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 *    IN THE SOFTWARE.
*/
#include "bratr_pch.h"

void CSettings::load_settings()
{
	const auto& settings_path = get_settings_filepath();

	if (!std::filesystem::exists(settings_path))
	{
		CConsole::get().output_info("Can't load settings! The file doens't exist. Will need to create one!");

		write_settings();
		return;
	}

	std::ifstream ifs(settings_path, std::ios_base::in);

	if (ifs.bad())
	{
		CDialogManager::get().display_error(std::format("Couldn't open settings file for read: {}", settings_path));
		return;
	}

	m_hide_left_side = read_value(k_settings_section_name, "hide_left_side");
	m_render_prefixes = read_value(k_settings_section_name, "render_prefixes");
	m_render_number_prefix = read_value(k_settings_section_name, "render_number_prefix");
	m_render_small_letter_prefix = read_value(k_settings_section_name, "render_small_letter_prefix");
	m_render_capital_letters_prefix = read_value(k_settings_section_name, "render_capital_letters_prefix");
	m_render_capital_letter_groups_prefix = read_value(k_settings_section_name, "render_capital_letter_groups_prefix");
	m_render_small_greek_letters_prefix = read_value(k_settings_section_name, "render_small_greek_letters_prefix");
	m_render_capital_greek_letters_prefix = read_value(k_settings_section_name, "render_capital_greek_letters_prefix");
	m_render_hover_unciode_offset_tooltip = read_value(k_settings_section_name, "render_hover_unciode_offset_tooltip");
	m_open_same_input_file = read_value(k_settings_section_name, "open_same_input_file");
	m_input_file = read_string(k_settings_section_name, "input_file");
	m_font_size = static_cast<ESettingsFont>(read_value(k_settings_section_name, "font_size"));
	m_language = static_cast<ELanguage>(read_value(k_settings_section_name, "language"));

	m_previously_opened_files.resize(k_previously_opened_files_n);

	for (uint32_t i = 0; i < k_previously_opened_files_n; i++)
		m_previously_opened_files[i] = read_string(k_settings_section_name, std::format("previously_opened_files{}", i));

	CConsole::get().output_info("Loaded settings!");

	ifs.close();
}

void CSettings::write_settings()
{
	const auto& settings_path = get_settings_filepath();

	std::ofstream ofs(settings_path, std::ios_base::out);

	if (ofs.bad())
	{
		CDialogManager::get().display_error(std::format("Couldn't open settings file for write: {}", settings_path));
		return;
	}

	ofs << 
		"// This file was auto-generated by the BraTr program.\n"
		"// And it's being regenerated everytime the program is closed.\n"
		"// Please do not change contents of this file.\n"
		"// Every setting can be found in the programs interface.\n";

	write_section(ofs, "root");
	write_value(ofs, "hide_left_side", m_hide_left_side);
	write_value(ofs, "render_prefixes", m_render_prefixes);
	write_value(ofs, "render_number_prefix", m_render_number_prefix);
	write_value(ofs, "render_small_letter_prefix", m_render_small_letter_prefix);
	write_value(ofs, "render_capital_letters_prefix", m_render_capital_letters_prefix);
	write_value(ofs, "render_capital_letter_groups_prefix", m_render_capital_letter_groups_prefix);
	write_value(ofs, "render_small_greek_letters_prefix", m_render_small_greek_letters_prefix);
	write_value(ofs, "render_capital_greek_letters_prefix", m_render_capital_greek_letters_prefix);
	write_value(ofs, "render_hover_unciode_offset_tooltip", m_render_hover_unciode_offset_tooltip);
	write_value(ofs, "open_same_input_file", m_open_same_input_file);
	write_string(ofs, "input_file", m_input_file);
	write_value(ofs, "font_size", m_font_size);
	write_value(ofs, "language", m_language);

	for (uint32_t i = 0; i < m_previously_opened_files.size(); i++)
		write_string(ofs, std::format("previously_opened_files{}", i), m_previously_opened_files[i]);

	CConsole::get().output_info("Wrote settings!");

	ofs.close();
}

void CSettings::write_value(std::ofstream& ofs, const std::string& key, uint32_t value) const
{
	ofs << key << " = " << std::to_string(value) << '\n';
}

void CSettings::write_string(std::ofstream& ofs, const std::string& key, const std::string& szvalue) const
{
	ofs << key << " = " << '"' << szvalue << '"' << '\n';
}

void CSettings::write_section(std::ofstream& ofs, const std::string& szSection) const
{
	ofs << '\n' << "[" << szSection << "]" << '\n';
}

int32_t CSettings::read_value(const std::string& szSection, const std::string& key) const
{
	char data[64];

	if (!GetPrivateProfileStringA(szSection.c_str(), key.c_str(), NULL,
								  data, sizeof(data),
								  get_settings_filepath().c_str()))
	{
		return 0;
	}

	return std::stoi(data);
}

std::string CSettings::read_string(const std::string& section, const std::string& key) const
{
	char data[64];

	if (!GetPrivateProfileStringA(section.c_str(), key.c_str(), NULL,
								  data, sizeof(data),
								  get_settings_filepath().c_str()))
	{
		return "";
	}

	return data;
}

std::string CSettings::get_settings_filepath() const
{
	return CFileSystem::get().get_file_inside_dir("Settings", "Config.ini").string();
}